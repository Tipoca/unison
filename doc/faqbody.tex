\TOPSUBSECTION{General Questions}{faqgeneral}

\begin{itemize}
\item {\em Does Unison work on Mac OSX?}

Unison has not been extensively tested on OSX, though several people say
they are using it successfully.  There are several known caveats:

\begin{itemize}
\item It does not understand resource forks and will refuse to synchronize
them.  Resource forks are not used by standard unix applications, but 
{\em are} used by many native mac applications.

\item Unison will be confused by some files that are frequently updated
by OSX, and will report lots of errors of the form ``XXX has been
modified during synchronization.''  These files --- 
in particular, files with names like {\tt .FBCLockFolder} and {\tt
  .FBCIndex} --- should be ignored by adding 
\begin{verbatim}
        ignore = Name .FBCIndex
        ignore = Name .FBCLockFolder
\end{verbatim}
to your profile.

\item We do not distribute pre-built binaries for OSX, but they can easily be
obtained from the Fink package distribution.

The textual user interface should compile ``straight out of the box''
according to the standard Unix installation instructions (once OCaml is
installed, either from Fink or by compiling it from sources, which is
straightforward).   

Compiling the graphical user interface is also fairly straightforward,
assuming you have already installed Fink (a very large collection of Unix
tools with a nice package system).  Proceed as follows:
\begin{itemize}
\item Use Fink to install an X server (e.g., XDarwin)
\item Use Fink to install the {\tt gtk} package (you may already have
installed it without realizing it, since it is required by a number of
other common packages).
\item Grab the {\tt lablgtk} distribution from 
\begin{quote}
\ONEURL{http://wwwfun.kurims.kyoto-u.ac.jp/soft/olabl/lablgtk.html}
\end{quote}
and install it according to the enclosed instructions.  (Make sure to
build the native-code versions of the libraries by doing 'make opt'
before 'make install.')
\item Go to the main unison directory and do 'make'.  (The {\tt
  UISTYLE=gtk} option should be selected automatically.)
\end{itemize}
\end{itemize}

Unison does not run on Mac OS 9 or earlier.  

\item {\em What are the differences between Unison and rsync?}

Rsync is a mirroring tool; Unison is a synchronizer.  That is, rsync
needs to be told ``this replica contains the true versions of all the
files; please make the other replica look exactly the same.''  Unison
is capable of recognizing updates in both replicas and deciding which way
they should be propagated.

Both Unison and rsync use the so-called ``rsync algorithm,'' by Andrew
Tridgell and Paul Mackerras, for performing updates.  This algorithm
streamlines updates in small parts of large files by transferring only
the parts that have changed.

\item {\em What are the differences between Unison and CVS?}

Both CVS and Unison can be used to keep a remote replica of a
directory structure up to date with a central repository.  Both are
capable of propagating updates in both directions and recognizing
conflicting updates.  Both use the rsync protocol for file transfer.

Unison's main advantage is being somewhat more automatic and easier to
use, especially on large groups of files.  CVS requires manual
notification whenever files are added or deleted.  Moving files is a
bit tricky.  And if you decide to move a directory... well, heaven
help you.

CVS, on the other hand, is a full-blown version control system, and it
has {\em lots} of other features (version history, multiple branches,
etc.)  that Unison (which is just a file synchronizer) doesn't have.

\item {\em Has anybody tried to use Unison in conjunction with CVS
 in order to replicate a CVS repository for active development in more than
 one geographical location at the same time?
 Do you forsee any issues with trying to do such a thing, or do you have any
 tips as to how to get a setup like that working?}

Unison and CVS can be used together.  The easiest way is to replicate
your files with Unison but keep your CVS repository on just one machine
(and do a commit on that machine after each time you synchronize with
Unison, if files in that directory have changed).  

More complex schemes are also possible (e.g., using a remote CVS server
and checking in from any host with one of the replicas), but should be
used with care.  In particular, if you use a remote CVS server, it is
important that you do {\em not} tell Unison to {\tt ignore} the files in
the {\tt CVS} subdirectory.

\item {\em Is it OK to mount my remote filesystem using NFS and
  run unison locally, or should I run a remote server process?}

NFS-mounting the replicas is fine, as long as the local network is
fast enough.  Unison needs to read a lot of files (in particular, it
needs to check the last-modified time of every file in the repository
every time it runs), so if the link bandwidth is low then running a
remote server is much better.

\item {\em When I run Unison on Windows, it creates two different
  windows, the main user interface and a blank console window.  Is
  there any way to get rid of the second one?}

The extra console window is there for ssh to use to get your password.
Unfortunately, in the present version of unison the window will appear
whether you're using ssh or not.

Karl Moerder contributed some scripts that he uses to make the command
window a bit more attractive.  He starts unison from a shortcut to a
\verb|.cmd| file. This lets him control the attributes of the command
window, making it small and gray and centering the passphrase request.
His scripts can be found at 
\ONEURL{http://www.cis.upenn.edu/$\sim$bcpierce/unison/download/resources/karls-winhax.zip}.

It is also possible to get rid of the window entirely (for users that
only want socket mode connections) by playing games with icons.  
If you make a symbolic link to the executable, you can edit the
properties box to make this window come up iconic.  That way when you
click on the link, you seem to just get a unison window (except on the
task bar, where the text window shows).  

\item {\em Will unison behave correctly if used transitively?  That is,
  if I synchronize both between \verb|host1:dir| and \verb|host2:dir| and
  between \verb|host2:dir| and \verb|host3:dir| at different times?  Are
  there any problems if the ``connectivity graph'' has loops?}

This mode of usage will work fine.  As far as each ``host pair'' is
concerned, filesystem updates made by Unison when synchronizing any other
pairs of hosts are exactly the same as ordinary user changes to the
filesystem.  So if a file started out having been modified on just one
machine, then every time Unison is run on a pair of hosts where one has
heard about the change and the other hasn't will result in the change
being propagated to the other host.  Running unison between machines
where both have already heard about the change will leave that file
alone.  So, no matter what the connectivity graph looks like (as long as
it is not partitioned), eventually everyone will agree on the new value
of the file.

The only thing to be careful of is changing the file {\em again} on the first
machine (or, in fact, any other machine) before all the machines have
heard about the first change -- this can result in Unison reporting
conflicting changes to the file, which you'll then have to resolve by
hand.

\item {\em What will happen if I try to synchronize a special file (e.g.,
something in \verb|/dev|, \verb|/proc|, etc.)?}

Unison will refuse to synchronize such files.  It only understands
ordinary files, directories, and symlinks.

\item {\em Is it OK to run several copies of Unison concurrently?}

Unison is built to handle this case, but this functionality has not been
extensively tested.  Keep your eyes open.

\item {\em What will happen if I do a local (or NFS, etc.) sync and some
  file happens to be part of both replicas?}

It will look to Unison as though somebody else has been modifying the
files it is trying to synchronize, and it will fail (safely) on these
files.

\item {\em What happens if Unison gets killed while it is working?  Do I
  have to kill it nicely, or can I use {\tt kill -9}? What if the network
  goes down during a synchronization?  What if one machine crashes but
  the other keeps running?}

Don't worry; be happy.  See \sectionref{failures}{Invariants}.

\item {\em What about race conditions when both Unison and some other
  program or user are both trying to write to a file at exactly the same
  moment?} 

Unison works hard to make these ``windows of danger'' as short as
possible, but they cannot be eliminated completely.

\item {\em I've heard that the Unix file locking mechanism doesn't work
  very well under NFS.  Is this a problem for Unison?}

No.

\item {\em On Windows systems, it looks like the {\tt root} preferences
  are specified using backslashes, but {\tt path} and {\tt ignore}
  preferences are specified with forward slashes.  What's up with that?} 

Unison uses two sorts of paths: native filesystem paths, which use the
syntax of the host filesystem, and ``portable'' paths relative to the
roots of the replicas, which always use / to separate the path
components.  Roots are native filesystem paths; the others are
root-relative.

% \item {\em As a system admin, I have some files I need to duplicate on 2
%   machines. Some are under {\tt /etc}, some are under {\tt /usr}, some
%   are under {\tt /home}.  I use ssh.  But for changes to be written, I
%   have to run unison as root.  Needless to say I don't particularly like
%   the idea of giving ssh access to root user.  I would prefer to run ssh
%   as regular user, then su root, or something like that.  Any
%   suggestions?}

% You can configure the ssh server so that it only allow connections
% from a given host, and so that it only allows the command "unison -server".

% If that does not seem safe enough to you, you can alternatively use
% ssh port forwarding.

\item {\em What will happen if I run Unison after my archive files get
  deleted or damaged?}

A missing or damaged archive is treated the same as a completely empty
one.  This means that Unison will consider {\em all} the files in both
replicas to be new.  Any files that exist only in one replica will be
transferred to the other replica (because it will look as though they
have just been created); files that exist on both replicas but have
different contents will be flagged as conflicts; files that have the same
contents on both replicas will simply be noted in the rebuilt archive.

If just one of the archive files is missing or damaged, Unison will
ignore the other one and start from an empty archive.

\item {\em Why was Unison written in OCaml instead of
  Java/C/C++/Perl/Python/etc.?} 
 
{\bf Short answer:} for portability, performance, and general all-around
excellent engineering. (This question came up on the unison-users list in
the context of an OCaml compiler bug, but on the whole we have had very few
hassles of this sort, and the OCaml team has been very responsive to fixing
things.)
 
{\bf Longer answer:}
 
 An early version of Unison was written in Java. In many ways, this was
 fine (Java is a pretty nice language, if you don't mind the fact that
 your code gets about 10x longer than an equivalent ML version), but there
 were several serious problems with Java:
 
 [Disclaimer -- we switched to OCaml several years ago, and some of these
 points have undoubtedly gotten somewhat better in the interim.]
 
 \begin{itemize}
 \item poor run-time performance (huge memory footprints, poor GC, etc.,
 etc.)
 
 \item poor portability (despite all the "write-once-run-anywhere" hype, we
 had neverending hassles with this -- different Swing bugs on
 different platforms, Linux implementation always a year behind
 Windows and Solaris, etc., etc.)
 
 \item poor system-level APIs (in particular, no support for critical
 filesytem operations like fstat)
 
 \item poor distribution support (RMI is a nice design, but the
 implementation was unbelievably heavy and expensive)

 \item poor language support for programming  in the large (OCaml's module
 system is really helpful for designing and documenting interfaces, etc.).
 \end{itemize}

 When we switched to OCaml, all these hassles vanished. The one technical
 downside was that going to OCaml involved doing a certain amount of work
 ourselves that was done for us in Java. In particular, we had to roll
 our own RPC package. However, once this was done, we had something that
 was right for the job, and that we could understand and control.
 Moreover, it was fun. :-)
 
 There is, of course, a social downside of using OCaml rather than Java:
 the developer pool is {\em much} smaller. However, I don't think this has
 really made much of a difference for the success of the project --
 although the code is GPLed, most of it is pretty intense, and I suspect
 that there are not that many people even in the bigger Java community
 that would be capable of picking it up and contributing to the effort
 without significant help from us (e.g., spending a summer at Penn, or
 whatever). Conversely, switching to OCaml has made a huge difference for
 the core development team, and this has contributed significantly to the
 overall success of the project.
 
 All things considered, switching to OCaml was a huge win for Unison. If
 we had to do it again, we'd definitely use OCaml. If we were doing it again
 in an industrial setting where being able to hire lots of skilled
 programmers was a bigger issue than optimizing the energy of a small
 team, perhaps C++ or Java would win out.

\end{itemize}

\TOPSUBSECTION{Common Problems}{problems}

A general recommendation is that, if you've gotten into a state you don't
understand, deleting the archive files on both replicas (files with names
like {\tt arNNNNNNNNNNNNNNN} in the {\tt .unison} directory) will return
you to a blank slate.  If the replicas are identical, then deleting the
archives is always safe.  If they are not identical, then deleting the
archives will cause all files that exist on one side but not the other to
be copied, and will report conflicts for all non-identical files that
do exist on both sides.

(If you think the behavior you're observing is an actual bug, then you
might consider {\em moving} the archives to somewhere else instead of
deleting them, so that you can try to replicate the bad behavior and
report more clearly what happened.)

\begin{itemize}
\item {\em The text mode user interface fails with 
``\verb|Uncaught exception Sys_blocked_io|'' when running over ssh2.}

The problem here is that ssh2 puts its standard file descriptors into
non-blocking mode.  But unison and  ssh share the same stderr (so that
error messages from the server are displayed), and the nonblocking
setting interferes with Unison's interaction with the user.  This can be
corrected by redirecting the stderr when invoking Unison:
\begin{verbatim}
     unison -ui text <other args> 2>/dev/tty
\end{verbatim}
(The redirection syntax is a bit shell-specific.  On some shells, e.g.,
   csh and tcsh, you may need to write
\begin{verbatim}
   unison -ui text <other args>  > & /dev/tty
\end{verbatim}
instead.)   

\item {\em What does the following mean?}
\begin{verbatim}
    Propagating updates [accounting/fedscwh3qt2000.wb3]
    failed: error in renaming locally:
    /DANGER.README: permission denied
\end{verbatim}

It means that unison is having trouble creating the temporary file
DANGER.README, which it uses as a "commit log" for operations (such as
renaming its temporary file {\tt accounting/fedscwh3qt2000.wb3.unison.tmp} to
the real location {\tt accounting/fedscwh3qt2000.wb3}) that may leave the
filesystem in a bad state if they are interrupted in the middle.  This is
pretty unlikely, since the rename operation happens fast, but it is
possible; if it happens, the commit log will be left around and Unison
will notice (and tell you) the next time it runs that the consistency of
that file needs to be checked.

The specific problem here is that Unison is trying to create
DANGER.README in the directory specified by your HOME environment
variable, which seems to be set to /, where you do not have write
permission.

\item {\em 
The command line}
\begin{verbatim}
     unison work ssh://remote.dcs.ed.ac.uk/work
\end{verbatim}
{\em fails, with ``{\tt fatal error: could not connect to server.}''
But when I connect directly with {\tt ssh remote.dcs.ed.ac.uk/work},
I see that my {\tt PATH} variable is correctly set, and the unison
executable is found. }

In the first case, Unison is using {\tt ssh} to execute a command, and
in the second, it is giving you an interactive remote shell.  Under
some ssh configurations, these two use different startup sequences.
You can test whether this is the problem here by trying, e.g.,
\begin{verbatim}
    ssh remote.dcs.ed.ac.uk 'echo $PATH'
\end{verbatim}
and seeing whether your {\tt PATH} is the same as when you do
\begin{verbatim}
    ssh remote.dcs.ed.ac.uk 
    [give password and wait for connection]
    echo $PATH
\end{verbatim}

One method that should always work is this [thanks to Richard Atterer for
this]:
\begin{enumerate}
\item log into the machine, set up PATH so the program is found
\item execute
\begin{verbatim}
         echo "PATH=$PATH" >> ~/.ssh/environment
\end{verbatim}
\item Check in \verb|/etc/sshd_config| to make sure that ssh is configured
to read \verb|~/.ssh/environment| on startup:
\begin{verbatim}
         PermitUserEnvironment yes
\end{verbatim}
\end{enumerate}

All this seems to be controlled by the configuration of ssh, but we have
not understood the details---if someone does, please let us know.

\item {\em I'm having trouble getting unison working with openssh
    under Windows.  Any suggestions?}
  
  \URL{http://www.apocalypse.org/pub/u/antony}{Antony Courtney}
  contributed the following comment.
  \begin{quote}
    I ran in to some difficulties trying to use this ssh client with
    Unison, and tracked down at least one of the problems.  I thought
    I'd share my experiences, and provide a 'known good' solution for
    other users who might want to use this Windows / Unison / ssh /
    Cygwin combination.
    
    If you launch Unison from bash, it fails (at least for me).
    Running \verb+unison_win32-gtkui.exe+, I get a dialog box that
    reads:
\begin{verbatim}
        Fatal error: Error in checkServer: Broken pipe [read()]
\end{verbatim}
    and a message is printed to stderr in the bash window that reads:
\begin{verbatim}
        ssh: unison_win32-gtkui.exe: no address associated with hostname.
\end{verbatim}
    My guess is that this is caused by some incompatibility between
    the Ocaml Win32 library routines and Cygwin with regard to setting
    up argv[] for child processes.
  \end{quote}

The solution is to launch Unison from a DOS command prompt instead;
or see section~\ref{click}.

\item {\em When I use ssh to log into the server, everything looks fine
  (and I can see the Unison binary in my path).
  But when I do {\tt ssh <server> unison} it fails.  Why?}

\finish{Check that this is not a repeat.}

[Thanks to Nick Phillips    for the following explanation.]

It's simple. If you start ssh, enter your password etc. and then end up
in a shell, you have a login shell.

If you do "ssh myhost.com unison" then unison is not run in a login shell.

This means that different shell init scripts are used, and most people seem
to have their shell init scripts set up all wrong.

With bash, for example, your \verb|.bash_profile| {\em only} gets used if
you start 
a login shell. This usually means that you've logged in on the system console,
on a terminal, or remotely. If you start an xterm from the command line
you won't get a login shell in it. If you start a command remotely from
the ssh or rsh command line you also won't get a login shell to run it in
(this is of course a Good Thing -- you may want to run interactive commands
from it, for example to ask what type of terminal they're using today).

If people insist on setting their \verb|PATH| in their
\verb|.bash_profile|, then they 
should probably do at least one of the following:
\begin{enumerate}
\item 
stop it;
\item 
read the bash manual, section "INVOCATION";
\item 
set their path in their \verb|.bashrc|;
\item 
get their sysadmin to set a sensible system-wide default path;
\item 
 source their \verb|.bash_profile| from their \verb|.bashrc| ...
\end{enumerate}
It's pretty similar for most shells.

\item {\em Unison crashes with an ``out of memory'' error when used to
  synchronize really huge directories (e.g., with hundreds of thousands
  of files).}

You may need to increase your maximum stack size.  On Linux and Solaris
systems, for example, you can do this using the {\tt ulimit} command (see
the {\tt bash} documentation for details).

\item {\em Unison seems to be unable to copy a single really huge file.
  I get something like this:}
\begin{verbatim}
    Error in querying file information:
    Value too large for defined data type [lstat(...)]
\end{verbatim}

This is a limitation in the OCaml interface to the Unix system calls.
(The problem is that the OCaml library uses 32-bit integers to represent
file positions.  The maximal positive 'int' in OCaml is about 2.1E9.  Recent
OCaml versions have incorporated 64-bit ints and can deal with large files,
but these changes have not yet been incorporated in Unison.  

\item {\em Why does unison run so slowly the first time I start it?}

On the first synchronization, unison doesn't have any ``memory'' of what
your replicas used to look like, so it has to go through, fingerprint
every file, transfer the fingerprints across the network, and compare
them to what's on the other side.  Having done this once, it stashes away
the information so that in future runs almost all of the work can be done
locally on each side.

\item {\em I can't seem to override the paths selected in the profile by
  using a {\tt -path} argument on the command line.}

Right: the {\tt path} preference is additive (each use adds an entry to
the list of paths within the replicas that Unison will try to
synchronize), and there is no way to remove entries once they have gotten
into this list.  The solution is to split your preference file into
different ``top-level'' files containing different sets of {\tt path}
preferences and make them all include a common preference file to avoid
repeating the non-path preferences.  See \sectionref{profileegs}{Profile
  Examples} for a complete example. 

\item {\em I can't seem to override the roots selected in the profile by
  listing the roots on the command line.  I get ``Fatal error: Wrong
  number of roots (2 expected; 4 provided).''}

Roots should be provided {\em either} in the preference file {\em or} on
the command line, not both.  See \sectionref{profileegs}{Profile
  Examples} for further advice.

\item {\em I am trying to compile unison 2.7.7 using OCaml 3.04.  I get ``Values do not match'' error.}
  
  Unison 2.7.7 compiles with Ocaml 3.02.  Later versions of OCaml,
  include version 3.04, require by default all parameter labels for
  function calls if they are declared in the interface.  Adding the
  compilation option ``\verb|-nolabels|'' (by inserting a line
  ``\verb|CAMLFLAGS+=-nolabels|'' to the file named ``\verb|Makefile.OCaml|'')
  should solve the problem.  To compile the graphical user interface for Unison 2.7.7, use LablGtk 1.1.2 instead of LablGtk 1.1.3.

\item {\em I get a persistent 'rsync failure' error when transferring a
  particular file.  What can I do?}

We're not sure what causes this failure, but a workaround is to set the
{\tt rsync} flag to false.

\item {\em Unison reports ``file has been modified during synchronization,''
  even though I didn't touch anything}

What happens is that the destination file has been modified without its
modification time property being updated (Excel does this, for example).
So, in ``fastcheck'' mode, Unison may miss the modification.  When it needs
to overwrite a file, Unison makes a more thorough check than just looking at
the modification time, and then notices the modification, hence the error
message above.  The workaround is to run Unison with the {\tt fastcheck}
flag turned off from time to time.

\end{itemize}

\TOPSUBSECTION{Tricks and Tips}{tips}

\begin{itemize}
\item {\em I want to use Unison to synchronize really big replicas.  How
  can I improve performance?}

When you synchronize a large directory structure for the first time,
Unison will need to spend a lot of time walking over all the files and
building an internal data structure called an archive.  There is no way
around this: Unison uses these archives in a critical way to do its work.
While you're getting things set up, you'll probably save time if you
start off focusing Unison's attention on just a subset of your files, by
including the option {\tt -path \it some/small/subdirectory} on the
command line.  When this is working to your satisfaction, take away the
\verb|-path| option and go get lunch while Unison works.  This rebuilding
operation will sometimes need to be repeated when you upgrade Unison
(major upgrades often involve changes to the format of the archive files;
minor upgrades generally do not.)

Next, you make sure that you are not ``remote mounting'' either of your
replicas over a network connection.  Unison needs to run close to the
files that it is managing, otherwise performance will be very poor.  Set
up a client-server configuration as described in the installation section
of the manual.

If your replicas are large and at least one of them is on a Windows
system, you will probably find that Unison's default method for detecting
changes (which involves scanning the full {\em contents} of every file on
every sync---the only completely safe way to do it under Windows) is too
slow.  In this case, you may be interested in the {\tt fastcheck}
preference, documented in \sectionref{fastcheck}{Fast Update Checking}.

In normal operation, the longest part of a Unison run is usually the time
that it takes to scan the replicas for updates.  This requires examining
the filesystem entry for every file (i.e., doing an {\tt fstat} on each
inode) in the replica.  This means that the total number of inodes in the
replica, rather than the total size of the data, is the main factor
limiting Unison's performance.

Update detection times can be improved (sometimes dramatically) by
telling Unison to ignore certain files or directories.  See the
description of the {\tt ignore} and {\tt ignorenot} preferences in
\sectionref{prefs}{Preferences}.

(One could also imagine improving Unison's update detection by giving it
access to the filesystem logs kept by some modern ``journaling
filesystems'' such as ext3 or ReiserFS, but this has not been
implemented.  We have some ideas for how to make it work, but it will
require a bit of systems hacking that no one has volunteered for yet.)

Another way of making Unison detect updates faster is by ``aiming'' it at
just a portion of the replicas by giving it one or more {\tt path}
preferences.  For example, if you want to synchronize several large
subdirectories of your home directory between two hosts, you can set
things up like this:

\begin{itemize}
\item Create a common profile (called, e.g., {\tt common}) containing most of
your preferences, including the two roots:
\begin{verbatim}
     root = /home/bcpierce
     root = ssh://saul.cis.upenn.edu//home/bcpierce
     ignore = Name *.o
     ignore = Name *.tmp
     etc.
\end{verbatim}

\item Create a default profile {\tt default.prf} with {\tt path}
preferences for all of the top-level subdirectories that you want to keep
in sync, plus an instruction to read the {\tt common} profile:
\begin{verbatim}
     path = current
     path = archive
     path = src
     path = Mail
     include common
\end{verbatim}
Running {\tt unison default} will synchronize everything.

(If you want to synchronize {\em everything} in your  home directory, you
can omit the {\tt path} preferences from {\tt default.prf}.)

\item Create several more preference files similar to {\tt default.prf}
but containing smaller sets of {\tt path} preferences.  For example, {\tt
  mail.prf} might contain:
\begin{verbatim}
     path = Mail
     include common
\end{verbatim}
Now running {\tt unison mail} will scan and synchronize just your {\tt
  Mail} subdirectory.
\end{itemize}

Once update detection is finished, Unison needs to transfer the changed
files.  This is done using a variant of the {\tt rsync} protocol, so if
you have made only small changes in a large file, the amount of data
transferred across the network will be relatively small.  

Unison carries out many file transfers at the same time, so the per-file
set up time is not a significant performance factor.  

\item {\em Is it possible to run Unison from {\tt inetd} (the Unix
  internet services daemon)?}

Toby Johnson has contributed a
detailed
\URL{http://www.cis.upenn.edu/$\sim$bcpierce/unison/download/resources/xinetd-chroot-howto.txt}{chroot
  min-HOWTO} describing how to do this.  (Yan Seiner wrote an earlier
\URL{http://www.cis.upenn.edu/$\sim$bcpierce/unison/download/resources/inetd-howto.txt}{howto},
on which Toby's is based.)

\item {\em Is there a way to get Unison not to prompt me for a
    password every time I run it (e.g., so that I can run it every
    half hour from a shell script)?}
  
  It's actually {\tt ssh} that's asking for the password.  If you're
  running the Unison client on a Unix system, you should check out the
  'ssh-agent' facility in ssh.  If you do
\begin{verbatim}
      ssh-agent bash
\end{verbatim}
  (or {\tt ssh-agent startx}, when you first log in) it will start you a
  shell (or an X Windows session) in which all processes and
  sub-processes are part of the same ssh-authorization group.  If, inside
  any shell belonging to this authorization group, you run the {\tt
    ssh-add} program, it will prompt you {\em once} for a password and
  then remember it for the duration of the bash session.  You can then
  use Unison over {\tt ssh}---or even run it repeatedly from a shell
  script---without giving your password again.

  It may also be possible to configure {\tt ssh} so that it does not
  require any password: just enter an empty password when you create a
  pair of keys.  If you think it is safe enough to keep your private key
  unencrypted on your client machine, this solution should work even
  under Windows.

\item {\em Is there a way, under Windows, to click-start Unison and make
  it synchronize according to a particular profile?}

Greg Sullivan sent us the following useful trick: 

\begin{quote}
In order to make syncing a particular profile ``clickable'' from the
Win98 desktop, when the profile uses {\tt ssh}, you need to create a {\tt
  .bat} file that contains nothing but ``{\tt unison profile-name}''
(assuming {\tt unison.exe} is in the {\tt PATH}).  I first tried the
``obvious'' strategy of creating a shortcut on the desktop with the
actual command line ``{\tt unison profile}, but that hangs.  The {\tt
  .bat} file trick works, though, because it runs {\tt command.com} and
then invokes the {\tt .bat} file.
\end{quote}

\item {\em Can Unison be used with SSH's port forwarding features?}

Mark Thomas says the following procedure works for him:
\begin{quote}
After having problems with unison spawning a command line ssh in Windows
I noticed that unison also supports a socket mode of communication (great
software!) so I tried the port forwarding feature of ssh using a
graphical SSH terminal TTSSH:
\begin{quote}
\ONEURL{http://www.zip.com.au/$\sim$roca/ttssh.html}
\end{quote}

To use unison I start TTSHH with port forwarding enabled and login to 
the Linux box where the unison server (\verb|unison -socket xxxx|) is 
started automatically.  In windows I just run unison and 
connect to localhost (\verb|unison socket://localhost:xxxx/ ...|)
\end{quote}

\item {\em How can I use Unison from a laptop whose hostname changes
  depending on where it is plugged into the network?}

This is partially addressed by the {\tt rootalias} preference.  See the
discussion in \sectionref{archives}{Archive Files}.

\item {\em It's annoying that (on Unix systems) I have to type an ssh
  passphrase into a console window, rather than being asked for it in a
  dialog box.  Is there a better way?}

We have some ideas about how this might be done (by allocating a PTY and
using it to talk to ssh), but we haven't implemented them yet.  If you'd
like to have a crack at it, we'd be glad to discuss ideas and incorporate
patches.  

In the meantime, tmb has contributed a script that uses {\tt expectk} to
do what's needed.  It's available at
\ONEURL{http://www.cis.upenn.edu/$\sim$bcpierce/unison/download/resources/expectk-startup}.

\item {\em When Unison is transferring a large directory and one single
  file in the directory fails for some reason, the whole transfer is
  aborted.  Why can't all the other files be transferred anyway?}

This is a ``feature'' of unison that is, unfortunately, unlikely to
change soon.  When we first designed it, we wanted to give users a simple
rule: no matter what happens during transfer, each changed path (e.g., a
path where a directory has been created fresh on one side) will either be
transferred {\em completely} to the other side, or else nothing will have
happened to that path.

By hindsight, it would have been better to complicate the specification a
little and allow new directories to be partially transferred, even if
something goes wrong with transferring some of their contents.  But
making this chang now would involve a significant alteration to a very
critical (and already rather complex) piece of code.  William Lovas and I
looked at it over the summer and decided that, while it could certainly
be done, doing it in such a way that we'd be sure it was right would take
someone perhaps a couple days of effort.  We're still waiting to find
that couple of days (or a volunteeer :-).

\end{itemize}
